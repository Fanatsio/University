Эмуляция DOS на эмуляторе DOSBox Эмуляция компьютера стандарта MSX на эмуляторе MESS Эмуля́ция ( англ. emulation ) в вычислительной технике — комплекс программных, аппаратных средств или их сочетание, предназначенное для копирования (или эмулирования ) функций одной вычислительной системы ( гостя ) на другую, отличную от первой, вычислительную систему ( хост ) таким образом, чтобы эмулированное поведение как можно ближе соответствовало поведению оригинальной системы ( гостя ). Целью является максимально точное воспроизведение поведения в отличие от разных форм компьютерного моделирования , в которых имитируется поведение некоторой абстрактной модели. Например, моделирование урагана или химической реакции не является эмуляцией. Содержание 1 Эмуляция в вычислительной технике 2 Электронное архивирование 2.1 Преимущества 2.2 Препятствия 3 Медиаискусство 4 Применение эмуляции для разработки новых систем 5 Виды эмуляции 6 Структурный состав эмулятора 6.1 Подсистема памяти 6.2 Центральный процессор 6.3 Ввод и вывод 7 Эмуляция и симуляция 8 Моделирование логических схем 9 Функциональное моделирование 10 Эмуляция игровой приставки 11 Эмуляция терминала 12 См. также 13 Примечания 14 Литература 15 Ссылки Эмуляция в вычислительной технике [ править | править код ] Эмуляция связана с возможностью компьютерной программы в одном устройстве эмулировать ( имитировать ) другую программу или устройство. Например, многие принтеры разработаны таким образом, чтобы эмулировать принтеры HP Laserjet , так как для данных принтеров существует большое количество программного обеспечения. Если принтер, не произведенный HP, эмулирует принтер HP, тогда любая программа, разработанная для принтеров HP, сможет работать и с принтером другого производителя, получая при этом идентичную печать. Аппаратная эмуляция представлена эмуляторами, выполненными в виде отдельного устройства. Например, DOS -совместимые карты расширения наподобие Centris 610 и Performa 630, устанавливавшиеся в некоторые Macintosh для обеспечения возможности запуска DOS-программ с ПК . Другим примером являются аппаратные эмуляторы на основе ППВМ . Теоретически, согласно тезису Черча-Тьюринга , любая операционная среда может быть скопирована в другую, хотя на практике это часто бывает чрезвычайно сложно из-за того, что точное поведение скопированной системы не документируется и может быть определено только путем обратного проектирования. В тезисе также не говорится о том, что если производительность эмуляции будет меньше, чем у исходной системы, то скопированное программное обеспечение будет работать значительно медленнее, чем следовало бы на исходном оборудовании, с возможным возникновением остановок эмуляции или нестабильной работы. Электронное архивирование [ править | править код ] Стиль этой статьи неэнциклопедичен или нарушает нормы литературного русского языка . Статью следует исправить согласно стилистическим правилам Википедии . ( 20 февраля 2022 ) Основная статья: Электронное архивирование Эмуляция — один из способов электронного архивирования устаревающих вычислительных систем. В такой трактовке целью эмуляции является точное воспроизведение оригинального цифрового окружения, что может быть труднодостижимым и затратным по времени, однако позволяет работать с цифровыми объектами практически так же, как в их изначальном виде [ 1 ] . Эмуляция адресует аппаратное и программное окружение оригинального цифрового устройства и воссоздаёт его на современной машине [ 2 ] . Эмуляция позволяет пользователю получить доступ к любому типу прикладного программного обеспечения или операционных систем на современной платформе, причем программное обеспечение выполняется так же, как и в оригинальном окружении [ 3 ] . Джеффри Ротенберг (Jeffery Rothenberg), один из первых сторонников применения эмуляции для электронного архивирования, считает, что «идеальным было бы единое расширяемое долговременное решение, которые могло бы быть разработанным раз и навсегда и применялось бы единообразно, автоматически и синхронно (например, каждый цикл обновления) ко всем типам документов и носителей» [ 4 ] . Далее он замечает, что это решение должно применяться не только к устаревшим системам, но и быть легко переносимым на пока неизвестные будущие системы [ 5 ] . На практике в случае, если выпускается новая версия приложения с целью обеспечения совместимости и миграции всех входящих в него компонентов, необходимо для этого приложения создать эмулятор, обеспечивающий доступ ко всем упомянутым компонентам. Преимущества [ править | править код ] Эмуляция сохраняет вид, поведение и ощущение от оригинальных систем, что не менее важно, чем данные сами по себе [ 3 ] . Несмотря на высокую изначальную стоимость создания эмулятора, со временем эмуляторы могут становиться более финансово выгодным решением [ 6 ] . Сокращает трудозатраты, так как вместо долгой и постоянно продолжающейся работы по миграции данных для каждого цифрового объекта при внесении библиотек приложений и операционных систем прошлого и настоящего в эмулятор для работы со всеми документами можно использовать одинаковые технологии [ 3 ] . Многие эмуляторы разработаны и доступны под лицензией GNU General Public License как открытое программное обеспечение , что расширяет масштабы сотрудничества [ 2 ] . Эмуляция позволяет использовать программное обеспечение, эксклюзивное для одной платформы, на другой платформе. Например, игры, эксклюзивные для PlayStation 2 , могут быть эмулированы на ПК или Xbox One . Это особенно полезно, когда оригинальная система труднодоступна для обретения или несовместима с современным оборудованием (например, старые игровые приставки может быть технически невозможно подключить к современным телевизорам). Препятствия [ править | править код ] Интеллектуальная собственность . Многие технологические компании, чтобы занять свою нишу на рынке, применяют при разработке своих продуктов нестандартизированные функции, постоянно внедряя улучшения, чтобы продукт оставался конкурентоспособным. Хоть это и приносит пользу, насыщая рынок технологичными продуктами и увеличивая рыночную долю продукта, это создаёт существенные проблемы пользователям, занимающимся архивированием, ввиду отсутствия всей необходимой документации, так как аппаратное и программное обеспечение проприетарно по своей сути [ 7 ] . Законы об авторских правах до сих пор не регламентируют защиту документации и спецификаций проприетарного оборудования и программ, встроенных в эмулятор [ 8 ] . Эмуляция часто используется в пиратских целях , поскольку эмуляторы освобождают пользователя от необходимости покупать оригинальное устройство, например игровую консоль , и крайне редко содержат какие-либо средства противодействия использованию нелегальных копий. Это приводит к весомой неопределенности правового положения эмуляции и к тому, что в программное обеспечение закладываются средства, препятствующие его работе в случае их запуска на эмуляторе. В компьютерных играх пользователь иногда может продолжить игру, но на последующих уровнях игра может становиться невозможной, что воспринимается либо как небрежность программиста , либо как просто чрезмерная сложность [ 9 ] [ 10 ] . Такая защита способствует созданию более точных эмуляторов, которые бы не вызывали срабатывание программной защиты, которая зачастую не очевидна. Медиаискусство [ править | править код ] Так как медиаискусство в основном создаётся в цифровом формате, эмуляция для него крайне важна как средство электронного архивирования . Такие деятели как, например, Cory Arcangel восстанавливают устаревшие технологии и используют их в своем творчестве, высоко оценивая важность децентрализованного и неофициального процесса сохранения цифровой культуры. Эмуляция часто используется в медиаискусстве как средство сохранения цифровой информации, которая бы впоследствии воспроизводилась без изменений, независимо от оборудования, подверженного старению и устареванию. Парадокс заключается в том, что эмуляция и эмуляторы должны быть созданы, чтобы работать на машинах будущего [ 11 ] . Применение эмуляции для разработки новых систем [ править | править код ] Разные виды эмуляции широко используются при разработке и проектировании новых систем. Эмуляция упрощает разработку, давая возможность определить, исследовать и устранить недостатки проекта до его физического воплощения [ 12 ] . Особенно эмуляция полезна при разработке многоядерных систем, в которых конфликты параллельной обработки часто достаточно сложно определить и диагностировать без применения виртуальной управляемой аппаратуры, доступной при эмуляции [ 13 ] . Также эмуляция позволяет приступить к разработке программного обеспечения до фактического изготовления аппаратной части [ 14 ] , таким образом проверяя заложенные в неё особенности. Виды эмуляции [ править | править код ] В большинстве существующих эмуляторов воспроизводится только аппаратное обеспечение. Таким образом, если требуется операционная система, хранящаяся в ПЗУ, или другое программное обеспечение, его следует получить дополнительно (впрочем, оно тоже может быть эмулировано). В дальнейшем и операционная система , и программное обеспечение будут интерпретированы эмулятором таким же образом, как и на изначальном оборудовании. Кроме интерпретатора эмулированных двоичных машинных кодов также должно эмулироваться и некоторое другое оборудование (например, вводные и выводные устройства). Например, если запись в определенную область памяти должна выводить что-то на экран, такое поведение также должно быть эмулировано. В пределе эмулятор должен исходить из модели, созданной на основе параметров и особенностей оригинального схемотехнического решения, включающего виртуальный источник питания, но на практике это было бы исключительным решением. Как правило, эмуляторы отталкиваются от модели, построенной на имеющейся документации и логической схеме устройства. Для эмуляции некоторых систем важным оказывается высокая точность эмуляции вплоть до тактовой частоты отдельных элементов, недокументированных функций, непредсказуемых аналоговых компонентов и допущенных ошибок. Особенно это важно при реализации эмуляторов классических домашних компьютеров типа Commodore 64 , программы для которых часто пользуются утонченными низкоуровневыми приемами программирования, разработанными создателями игры и демосценой . Наоборот, некоторые другие устройства имели очень ограниченный прямой доступ к оборудованию. В подобных случаях может быть достаточно простого слоя совместимости. Системные запросы эмулируемой программы транслируются в системные запросы хоста, то есть в системах FreeBSD , NetBSD и OpenBSD для запуска Linux -приложений с закрытым кодом используется слой совместимости с Linux. Например, графический процессор Nintendo 64 был полностью программируемым, и большинство разработчиков игр использовало заложенные заводские программы, которые были самодостаточными и обменивались информацией с игрой через буфер FIFO . Поэтому многие эмуляторы вообще не эмулируют графический процессор, интерпретируя вместо этого команды центрального процессора так же как и оригинальная программа. Разработчики программ для встраиваемых систем и игровых приставок часто создают свои продукты на особо точных эмуляторах, называемых симуляторами , перед запуском на физическом оборудовании. Это делается для возможности создания и тестирования до запуска в производство окончательной ревизии оборудования, а также для возможности быстрой отладки программы без затрат времени на копирование и внесение побочных эффектов отладчика . Во многих случаях симулятор создается и предоставляется изготовителем оборудования, что теоретически должно повышать его точность. Эмуляция математического сопроцессора применяется для запуска программ, скомпилированных с использованием математических инструкций, на машинах без установленного сопроцессора, на которых дополнительная нагрузка на центральный процессор может негативно сказаться на производительности. Если сопроцессор не установлен и не встроен в центральный процессор, при выполнении математической инструкции будет вызвано прерывание (отсутствие сопроцессора), запускающее подпрограмму математического эмулятора. После успешного выполнения инструкции управление возвращается программе. Структурный состав эмулятора [ править | править код ] Как правило эмулятор состоит из нескольких модулей , каждый из которых соответствует отдельной эмулируемой подсистеме оригинального устройства. В наиболее общем случае эмулятор состоит из следующих блоков: модуль эмуляции или симуляции CPU (в данном случае термины практически равнозначны); модуль эмуляции подсистемы памяти; модули эмуляции различных устройств ввода-вывода. Системные шины в целях упрощения эмуляции и увеличения производительности, как правило, не эмулируются. Вместо этого виртуальная периферия обращается непосредственно к процессору или подсистеме памяти. Подсистема памяти [ править | править код ] При эмуляции вполне возможно отобразить всю подсистему памяти в виде простого массива, каждый элемент которого имеет размер эмулированного слова. Однако этот подход обречен на неудачу, потому что в этом случае никакой логический адрес памяти не будет совпадать с физической памятью. Наиболее ярко это проявляется в случае, когда оригинальное оборудование обладает продвинутым управлением памятью (в этом случае в модуле подсистемы памяти должна быть реализована логика MMU либо как отдельный модуль, либо как часть виртуального CPU). Однако даже если эмулируемое устройство не содержит MMU, существуют и другие факторы, нарушающие эквивалентность логической и физической памяти: многие (если не все) архитектуры обладают отображаемыми в ОЗУ портами ввода-вывода; даже те, которые ими не обладают, имеют блоки памяти, отображаемые в ПЗУ . Это значит, что представление памяти в виде массива не должно применяться, если требуется эмулировать ПЗУ. Функции типа переключения банков или сегментной адресации также могут усложнить эмуляцию памяти. В результате большинство эмуляторов имеет по меньшей мере две процедуры — для чтения из памяти и для записи в память, — которые ответственны за доступ к правильной области правильного объекта. Для эмуляции систем с ограниченной адресацией, где адреса памяти с 0 по (размер ПЗУ) — 1 доступны только для чтения, а все остальные принадлежат ОЗУ, что-то подобное следующему является вполне типичным. void WriteMemory ( word Address , word Value ) { word RealAddress ; RealAddress = Address + BaseRegister ; if (( RealAddress < LimitRegister ) && ( RealAddress > ROMSIZE )) { Memory [ RealAddress ] = Value ; } else { RaiseInterrupt ( INT_SEGFAULT ); } } word ReadMemory ( word Address ) { word RealAddress ; RealAddress = Address + BaseRegister ; if ( RealAddress < LimitRegister ) { return Memory [ RealAddress ]; } else { RaiseInterrupt ( INT_SEGFAULT ); return NULL ; } } Центральный процессор [ править | править код ] Как правило, модуль CPU — самая сложная часть эмулятора. Во многих эмуляторах используются предварительно «подготовленные» модули CPU, чтобы сосредоточиться на качественной и эффективной эмуляции. Интерпретатор — простейшая форма эмуляции CPU. Это — программа, которая следует за потоком выполнения программы и для каждой встречающейся машинной инструкции выполняет операции, семантически эквивалентные оригинальным инструкциям, на процессоре хоста. Это возможно назначением переменных для каждого регистра и флага эмулируемого CPU. Логика работы эмулированного CPU может быть с большей или меньшей сложностью реализована в алгоритме программы, создавая программную реализацию, которая в большей или меньшей степени отражает оригинальное оборудование. Следующий пример показывает, как с помощью интерпретатора можно осуществить эмуляцию CPU. В данном примере опрос прерываний происходит перед выполнением инструкции, однако из-за низкой производительности этот способ редко используется в существующих эмуляторах (в целом быстрее использовать подпрограмму, выполняющую роль прерывания). void Execute ( void ) { if ( Interrupt != INT_NONE ) { SuperUser = TRUE ; WriteMemory ( ++ StackPointer , ProgramCounter ); ProgramCounter = InterruptPointer ; } switch ( ReadMemory ( ProgramCounter ++ )) { /* * Handling of every valid instruction * goes here... */ default : Interrupt = INT_ILLEGAL ; } } Интерпретаторы весьма популярны для моделирования вычислительных машин, так как их реализация намного проще, нежели выигрывающие в производительности другие решения, так как скорость их работы зачастую достаточна для эмуляции компьютеров, которые в буквальном смысле на десяток лет старше современных машин. Однако применение интерпретации с присущим ей снижением производительности может быть проблемой, когда требуется эмулировать компьютер с процессором, производительность которого соответствует порядку величины производительности процессора хоста. До недавнего времени эмуляция в подобных случаях многими считалась бесполезной. Преодолеть эти ограничения помог прогресс в технике динамической компиляции. Простая трансляция эмулированного программного кода в код, выполнимый на архитектуре хоста, невозможна априори по нескольким причинам: код может являться самомодифицирующимся, даже если модификация происходит только во время загрузки кода эмулированной операционной системой (например, с диска); может не существовать надежного способа разделения данных (не транслируются) и исполняемого кода . Чтобы обойти эти проблемы применяют разнообразные приемы, включая известную « компиляцию на лету ». Компилятор ожидает, пока поток управления процессором не перейдет в область, содержащую нетранслированный код. Только тогда («на лету») происходит трансляция блока кода в код, который может быть выполнен. Обработанный код помещается в кэш кода , при этом оригинальный код не подвергается изменению. В таком случае даже блоки данных подвергнутся бессмысленной трансляции компилятором, единственным эффектом чего будет увеличение времени работы транслятора. В некоторых случаях, например при запуске старых игр, высокая скорость эмуляции может быть нежелательной, так как игры создавались без оглядки на производительность компьютеров будущего. В игре, разработанной для ПК с CPU 30 MHz, игроку может отводиться 300 игровых секунд на игровой уровень, в случае запуска той же игры на ПК с CPU 300 MHz игроку эти 300 игровых секунд будут соответствовать 30 реальным секундам. Другие программы, например некоторые программы для DOS, вообще не смогут запуститься на быстром компьютере. Практически, если эмулируется система, являвшаяся «чёрным ящиком», изменения в ядре которого не ожидались, программы могут зависеть от некоторых специфических параметров оборудования (например, частоты CPU). Таким образом, для правильной эмуляции подобных приложений требуется очень точное управление скоростью эмуляции. Ввод и вывод [ править | править код ] Как уже было отмечено, системные шины эмулируются редко. Каждое устройство ввода-вывода рассматривается отдельно, потому как в эмуляторе отсутствует реализация какого-либо универсального интерфейса. Так как каждое устройство ввода-вывода может быть идеально подогнано к параметрам эмулированного устройства, это даёт выигрыш в производительности. Однако решения на основе стандартизованных, унифицированных API всё же могут составить конкуренцию упрощённым моделям в случае их грамотной, искусной реализации. Дополнительным преимуществом будет «автоматически» получаемая служба плагинов, через которую с эмулятором смогут работать сторонние виртуальные устройства. В унифицированных API ввода-вывода необязательно повторять полную структуру шины: её схемотехника ограничена несколькими электронными компонентами, таким образом, в программной реализации необязательно наличие системы разрешения конфликтов параллельных вычислений. Даже в эмуляторах, рассматривающих отдельно каждое устройство, как правило присутствует следующая виртуальная инфраструктура: управление прерываниями посредством процедуры, которая устанавливает флаги, считываемые эмулятором CPU, когда объявлено прерывание, что позволяет виртуальному CPU «опрашивать прерывания»; запись и чтение физической памяти посредством двух процедур, подобных обслуживающим логическую память (однако в отличие от последнего, первые часто могут быть заменены простыми ссылками на массив памяти). Эмуляция и симуляция [ править | править код ] Слово «эмулятор» было придумано в IBM [ 15 ] при разработке серии продуктов NPL ( IBM System/360 ), используя «новую комбинацию программы, микрокода и оборудования» [ 16 ] . Они обнаружили, что для исполнения программ, написанных для старых машин IBM, использование аппаратного Микрокода намного выгоднее по производительности, нежели программная симуляция. Ранее, в 1957 году, IBM поставляла программный интерпретатор для возможности запуска программ для более старого компьютера IBM 704 на компьютерах IBM 709 и IBM 7090 [ 17 ] . В 1964 году инженеры IBM придумали слово «эмуляция» для описания концепции первого применения микрокода для ускорения процесса симуляции. В последнее время употребление этого термина стало общеупотребительными в контексте программного обеспечения. До 1980-х годов слово «эмуляция» относилось исключительно к аппаратной реализации с применением микрокода, тогда как для программной эмуляции использовался термин «симуляция» [ 18 ] . Например, компьютер, специально разработанный для выполнения программ, написанный для другой архитектуры, являлся эмулятором. С другой стороны симулятором могла бы называться программа для ПК, с помощью которой можно было бы симулировать старые игры для Atari. Хотя пуристы продолжают указывать на это терминологическое различие, в настоящее время эмуляцией обычно принято называть полную имитацию машины, выполняющей двоичный код, тогда как симуляция в основном относится к компьютерному моделированию , работающему над абстрактной моделью. Компьютерное моделирование используется практически в любой научной и инженерной деятельности, не исключая также информатику, которая находит многие применения для работы с абстрактной моделью, например, моделирование сетей связи. Моделирование логических схем [ править | править код ] Моделирование логических схем — применение особого программного обеспечения с целью предсказать поведение цифровой схемы и языков описания аппаратуры . Моделирование может выполняться на различных уровнях физических абстракций: уровень транзисторов , уровень логических элементов , уровень регистровых передач или функциональный уровень. Моделирование осуществляется после разработки схемы в виде логических уравнений и до начала её физического производства. Функциональное моделирование [ править | править код ] Функциональное моделирование — использование компьютерной программы для моделирования выполнения другой компьютерной программы, написанной на языке ассемблера или в исходных кодах , а не в виде двоичного машинного кода . С помощью функционального моделирования программист может выпускать и анализировать работу выбранного участка кода для обнаружения ошибок (багов), не прибегая к получению двоичного кода. Этим оно отличается от выполнения бинарного кода, что является эмуляцией. Первое применение функционального моделирования осуществлено компанией Autonetics около 1960 года для тестирования программ на языке ассемблера, которые впоследствии должны были выполняться на военной машине D-17B. Это позволило писать, выполнять и тестировать полетное программное обеспечение до физического изготовления вычислительного оборудования D-17B. Эта же компания позднее применяла функциональное моделирование для тестирования полетного программного обеспечения, которое должно было выполняться на машине D-37C. Эмуляция игровой приставки [ править | править код ] Основная статья: Эмулятор игровой приставки Эмулятор игровой приставки — это программа, которая позволяет на персональном компьютере или игровой приставке эмулировать другую приставку. Чаще всего их используют для запуска старых игр на ПК или более современных приставках. Также эмуляторы используют для создания любительского перевода игр, модификаций игр, а также для разработки такого пользовательского контента как демоверсии и новые игры для старых систем. В распространении этого вида эмуляции большую роль сыграл интернет , так как большая часть (если не все) эмуляторов не доступна в точках розничных продаж. Некоторые из эмуляторов, выпущенные в последние два десятилетия: Dolphin , ZSNES , MAME , DeSmuME , ePSXe , Gens , VisualBoyAdvance , Jnes и Nestopia . Эмуляция терминала [ править | править код ] Основная статья: Эмулятор терминала Эмулятор терминала — это программа для современного ПК или другого устройства, позволяющая получить интерактивный доступ к операционной системе мейнфрейма или другой системе хоста, например HP-UX или OpenVMS . Уже длительное время терминалы наподобие IBM 3270 и VT100 не производятся. Вместо этого используется программа, запускаемая на современной операционной системе, которая имитирует «глупый» терминал и способна отображать графические и текстовые элементы приложения хоста, отправлять клавиатурный ввод и обрабатывать команды через соответствующий протокол терминала. Некоторые из таких эмуляторов включают приложения для Attachmate Reflection, IBM Personal Communications, AlphaVM virtual machine от EmuVM, Stromasys CHARON-VAX/AXP и Micro Focus Rumba. См. также [ править | править код ] Список эмуляторов игровых консолей Компьютерное моделирование Некоторые виды эмуляторов: Эмулятор игровой приставки Эмулятор сервера Эмулятор терминала Эмулятор оптических дисководов Двоичная трансляция Внутрисхемный эмулятор: JTAG QEMU Виртуальная машина Примечания [ править | править код ] ↑ What is emulation? (неопр.) Koninklijke Bibliotheek . Дата обращения: 11 декабря 2012. Архивировано из оригинала 7 июня 2011 года. ↑ 1 2 van der Hoeven, Jeffrey, Bram Lohman, and Remco Verdegem. Emulation for Digital Preservation in Practice: The Results . The International Journal of Digital Curation 2.2 (2007): 123—132. ↑ 1 2 3 Muira, Gregory. Pushing the Boundaries of Traditional Heritage Policy: maintaining long-term access to multimedia content . IFLA Journal 33 (2007): 323—326. ↑ Rothenberg, Jeffrey. "Criteria for an Ideal Solution." Avoiding Technological Quicksand: Finding a Viable Technical Foundation for Digital Preservation. (неопр.) Council on Library and Information Resources (1998). Дата обращения: 8 марта 2008. Архивировано из оригинала 20 февраля 2008 года. ↑ Rothenberg, Jeffrey. The Emulation Solution . Avoiding Technological Quicksand: Finding a Viable Technical Foundation for Digital Preservation. Washington, DC: Council on Library and Information Resources, 1998. Council on Library and Information Resources. 2008. 28 Mar. 2008 http://www.clir.org/pubs/reports/rothenberg/contents.html Архивная копия от 20 февраля 2008 на Wayback Machine ↑ Granger, Stewart. Digital Preservation & Emulation: from theory to practice. Proc. of the ichim01 Meeting, vol. 2, 3 −7 Sept. 2001. Milano, Italy. Toronto: Archives and Museum Informatics, University of Toronto, 2001. 28 Mar. 2008 http://www.leeds.ac.uk/cedars/pubconf/papers/ichim01SG.html Архивная копия от 31 января 2009 на Wayback Machine ↑ Granger, Stewart. Emulation as a Digital Preservation Strategy . D-Lib Magazine 6.19 (2000). 29 Mar 2008 http://www.dlib.org/dlib/october00/granger/10granger.html Архивная копия от 4 октября 2012 на Wayback Machine ↑ Rothenberg, Jeffrey. The Emulation Solution . Avoiding Technological Quicksand: Finding a Viable Technical Foundation for Digital Preservation. Washington, DC: Council on Library and Information Resources, 1998. Council on Library and Information Resources. 2008. 28 Mar. 2008 ↑ Pokémon Black and White — The Cutting Room Floor (неопр.) . Дата обращения: 25 мая 2013. Архивировано из оригинала 6 июня 2013 года. ↑ Mega Man Star Force — The Cutting Room Floor (неопр.) . Дата обращения: 25 мая 2013. Архивировано из оригинала 12 мая 2013 года. ↑ Echoes of Art: Emulation as preservation strategy (неопр.) . Дата обращения: 11 декабря 2007. Архивировано из оригинала 27 октября 2007 года. ↑ Peter Magnusson. Full System Simulation: Software Development's Missing Link (неопр.) (2004). Дата обращения: 25 мая 2013. Архивировано 25 мая 2013 года. ↑ Debugging and Full System Simulation (неопр.) . Дата обращения: 25 мая 2013. Архивировано из оригинала 8 октября 2008 года. ↑ Vania Joloboff. Full System Simulation of Embedded Systems (неопр.) (2009). Дата обращения: 25 мая 2013. Архивировано из оригинала 9 февраля 2014 года. ↑ Pugh, Emerson W. Building IBM: Shaping an Industry and Its Technology (англ.) . — MIT, 1995. — P. 274 . — ISBN 0-262-16147-8 . ↑ Pugh, Emerson W.; et al. IBM's 360 and Early 370 Systems (неопр.) . — MIT, 1991. — ISBN 0-262-16123-0 . pages 160—161 ↑ «7090 Data Processing System» — «Compatibility feature for IBM 704 programs» subsection Архивная копия от 20 августа 2018 на Wayback Machine ↑ S. G. Tucker, Emulation of Large Systems . Communications of the ACM (CACM) Vol. 8, No. 12, Dec. 1965, pp. 753—761 Литература [ править | править код ] А. Аганичев, Д. Панфилов, М. Плавич, О. Полянский. Программно-аппаратный комплекс для отладки МП систем на основе микроконтроллеров семейства MC68HC11 фирмы MOTOROLA Шагурин И., Бродин В., Калинин Л., Толстов Ю., Петров С., Исенин И., Эйдельман С., Ванюлин В. Средства проектирования и отладки систем управления на базе МК фирмы Motorola. Ссылки [ править | править код ] Как написать эмулятор компьютера How to write a computer Emulator Программное обеспечение для эмуляции и виртуализации ( сравнение ) Уровень приложений Ceedo Citrix XenApp Dalvik InstallFree Microsoft App-V Spoon Symantec Workspace Virtualization VMware ThinApp ZeroVM Уровень ОС (Контейнеры) Основанные на cgroups : CoreOS lmctfy LXC Docker OpenVZ Virtuozzo Прочие: Linux-VServer FreeBSD jail iCore Virtual Accounts Kubernetes Solaris Containers Workload Partitions Аппаратный уровень Универсальные Микроядро Hyper-V LynxSecure Oracle VM Server for SPARC VMware ESX/ESXi Adeos Xen XtratuM z/VM Монолитные bhyve KVM L 4 Linux Microsoft Virtual Server Parallels Workstation Parallels Desktop for Mac Parallels Server for Mac PearPC QEMU VirtualBox Virtual Iron Virtual Machine Manager VMware Fusion VMware Server VMware Workstation / VMware Player Windows Virtual PC Win4Lin Специализированные Android Andy BlueStacks App Player Droid4X Genymotion MEmu NoxPlayer LDPlayer DOS DOSBox DOSEMU PCem 86Box Прочие Bochs PikeOS Proxmox Virtual Environment oVirt Список эмуляторов игровых приставок Виртуализация сетей DOVE [англ.] Open vSwitch Virtual security switch VXLAN Источник — https://ru.wikipedia.org/w/index.php?title=Эмуляция&oldid=143637297